"""
Robust Stress Test Runner for InsightForge Pipeline.

Replicates the exact flow of the bash script:
1. Parallel Uploads (mimics xargs -P 15)
2. Sequential Polling Loop (mimics while true; do for id...; done)
3. Parallel Insights (mimics xargs -P 10)
4. Sequential Insight Polling (mimics while true; do for id...; done)

Handles httpx connection errors (Server disconnected) robustly.
"""

import asyncio
import argparse
import os
import uuid
import time
import httpx
from pathlib import Path
from dataclasses import dataclass
from typing import List, Dict, Optional, Any

# Configuration
API_BASE_URL = os.getenv("IF_API_URL", "http://127.0.0.1:8008")
POLL_INTERVAL = 3.0  # Matches 'sleep 3' from bash script

class TestLogger:
    @staticmethod
    def info(msg: str):
        print(f"‚ÑπÔ∏è  {msg}")

    @staticmethod
    def success(msg: str):
        print(f"‚úÖ {msg}")

    @staticmethod
    def warning(msg: str):
        print(f"‚ö†Ô∏è  {msg}")

    @staticmethod
    def error(msg: str):
        print(f"‚ùå {msg}")

    @staticmethod
    def section(title: str):
        print("\n" + "=" * 80)
        print(f" {title}")
        print("=" * 80)

class ApiClient:
    def __init__(self, base_url: str = API_BASE_URL):
        self.base_url = base_url
        # Disable keep-alive to mimic curl and avoid "Server disconnected" on reused connections
        # under heavy load.
        limits = httpx.Limits(max_keepalive_connections=0, max_connections=100)
        self.client = httpx.AsyncClient(base_url=base_url, timeout=60.0, limits=limits)

    async def close(self):
        await self.client.aclose()

    async def _request(self, method: str, url: str, **kwargs) -> httpx.Response:
        """Robust request wrapper with retries for connection issues."""
        max_retries = 3
        for attempt in range(max_retries):
            try:
                response = await self.client.request(method, url, **kwargs)
                return response
            except (httpx.RemoteProtocolError, httpx.ReadTimeout, httpx.ConnectError) as e:
                if attempt == max_retries - 1:
                    raise
                # Exponential backoff for retries
                await asyncio.sleep(0.5 * (2 ** attempt))
                continue
        raise RuntimeError("Unreachable code")

    async def health_check(self) -> bool:
        try:
            resp = await self._request("GET", "/health")
            return resp.status_code == 200
        except Exception:
            return False

    async def upload_document(self, user_id: str, file_path: Path) -> str:
        if not file_path.exists():
            raise FileNotFoundError(f"{file_path} not found")
        
        filename = file_path.name
        with open(file_path, "rb") as f:
            files = {"file": (filename, f, "application/pdf")}
            data = {"user_id": user_id}
            resp = await self._request("POST", "/documents", data=data, files=files, timeout=120.0)
            
        if resp.status_code >= 400:
            raise ValueError(f"Upload failed {resp.status_code}: {resp.text}")
            
        return resp.json()["doc_id"]

    async def get_document(self, doc_id: str) -> Dict[str, Any]:
        resp = await self._request("GET", f"/documents/{doc_id}")
        if resp.status_code >= 400:
            raise ValueError(f"Get doc failed {resp.status_code}: {resp.text}")
        return resp.json()

    async def create_insight(self, user_id: str, doc_ids: List[str], action: str, title: str) -> str:
        payload = {
            "user_id": user_id,
            "action_type": action,
            "document_ids": doc_ids,
            "title": title,
            "instructions": "Generated by StressTest"
        }
        resp = await self._request("POST", "/insights", json=payload, timeout=30.0)
        if resp.status_code >= 400:
            raise ValueError(f"Create insight failed {resp.status_code}: {resp.text}")
        return resp.json()["insight_id"]

    async def get_insight(self, insight_id: str) -> Dict[str, Any]:
        resp = await self._request("GET", f"/insights/{insight_id}")
        if resp.status_code >= 400:
            raise ValueError(f"Get insight failed {resp.status_code}: {resp.text}")
        return resp.json()

    async def chat_message(self, user_id: str, message: str, doc_ids: List[str]) -> Dict[str, Any]:
        payload = {
            "user_id": user_id,
            "message": message,
            "document_ids": doc_ids
        }
        resp = await self._request("POST", "/chat/message", json=payload, timeout=120.0)
        if resp.status_code >= 400:
            raise ValueError(f"Chat failed {resp.status_code}: {resp.text}")
        return resp.json()

    async def get_chat_history(self, user_id: str) -> Dict[str, Any]:
        resp = await self._request("GET", f"/chat/history?user_id={user_id}")
        if resp.status_code >= 400:
            raise ValueError(f"Get chat history failed {resp.status_code}: {resp.text}")
        return resp.json()


class StressTestRunner:
    def __init__(self):
        self.api = ApiClient()
        self.user_id = str(uuid.uuid4())
        self.doc_ids: List[str] = []
        self.doc_map: Dict[str, str] = {} # id -> filename

    # ============================================================================
    # STRESS TEST (COMMENTED OUT - Use --stress flag to enable)
    # ============================================================================
    # async def run_stress_test(self, folder_path: str, max_files: int = 15):
    #     TestLogger.section(f"üöÄ STARTING STRESS TEST (Max {max_files} files)")
    #     
    #     # 1. Gather files
    #     p = Path(folder_path)
    #     files = sorted(list(p.glob("*.pdf")))
    #     if not files:
    #         TestLogger.error(f"No PDF files found in {folder_path}")
    #         return
    #     target_files = files[:max_files]
    #     TestLogger.info(f"Found {len(files)} files, selecting top {len(target_files)}")
    #
    #     # 2. Parallel Uploads
    #     TestLogger.section("üì§ Step 1: Parallel Uploads (15 concurrent)")
    #     
    #     async def upload_wrapper(fp: Path):
    #         try:
    #             doc_id = await self.api.upload_document(self.user_id, fp)
    #             print(f"   ‚¨ÜÔ∏è  Uploaded {fp.name} -> {doc_id}")
    #             return (doc_id, fp.name)
    #         except Exception as e:
    #             TestLogger.error(f"Failed to upload {fp.name}: {e}")
    #             return None
    #
    #     results = await asyncio.gather(*[upload_wrapper(f) for f in target_files])
    #     
    #     for res in results:
    #         if res:
    #             did, name = res
    #             self.doc_ids.append(did)
    #             self.doc_map[did] = name
    #
    #     TestLogger.success(f"Uploaded {len(self.doc_ids)}/{len(target_files)} documents.")
    #     if not self.doc_ids:
    #         return
    #
    #     # 3. Sequential Polling Loop (Matches bash script)
    #     TestLogger.section("‚è≥ Step 2: Polling Documents (Sequential Check Loop)")
    #     
    #     completed_ids = set()
    #     failed_ids = set()
    #     
    #     while len(completed_ids) + len(failed_ids) < len(self.doc_ids):
    #         # Check all pending docs
    #         current_completed = 0
    #         
    #         # We iterate through ALL ids just like the bash script
    #         for doc_id in self.doc_ids:
    #             if doc_id in completed_ids or doc_id in failed_ids:
    #                 if doc_id in completed_ids: current_completed += 1
    #                 continue
    #
    #             try:
    #                 doc = await self.api.get_document(doc_id)
    #                 status = doc["status"]
    #                 
    #                 if status == "completed":
    #                     print(f"   ‚úÖ {self.doc_map[doc_id]} -> completed")
    #                     completed_ids.add(doc_id)
    #                     current_completed += 1
    #                 elif status == "error":
    #                     print(f"   ‚ùå {self.doc_map[doc_id]} -> error: {doc.get('error_message')}")
    #                     failed_ids.add(doc_id)
    #                 else:
    #                     # Only log pending/processing occasionally or just rely on summary
    #                     pass
    #             except Exception as e:
    #                 print(f"   ‚ö†Ô∏è Error polling {doc_id}: {e}")
    #
    #         print(f"   --- Status: {len(completed_ids)} completed, {len(failed_ids)} failed, {len(self.doc_ids) - len(completed_ids) - len(failed_ids)} pending ---")
    #         
    #         if len(completed_ids) + len(failed_ids) == len(self.doc_ids):
    #             break
    #             
    #         await asyncio.sleep(POLL_INTERVAL)
    #
    #     # 4. Parallel Insights
    #     if not completed_ids:
    #         TestLogger.warning("No completed documents for insights.")
    #         return
    #
    #     valid_docs = list(completed_ids)
    #     # Take first 10 like the bash script
    #     docs_for_insights = valid_docs[:10]
    #     
    #     TestLogger.section(f"üß† Step 3: Parallel Insights (10 concurrent)")
    #     
    #     insight_ids = []
    #     
    #     async def insight_wrapper(doc_id):
    #         try:
    #             iid = await self.api.create_insight(
    #                 self.user_id, [doc_id], "summary", "Parallel Summary"
    #             )
    #             print(f"   üöÄ Created insight for {self.doc_map[doc_id]} -> {iid}")
    #             return iid
    #         except Exception as e:
    #             TestLogger.error(f"Failed to create insight: {e}")
    #             return None
    #
    #     # Bash script uses xargs -P 10 for insights. We replicate that.
    #     i_results = await asyncio.gather(*[insight_wrapper(did) for did in docs_for_insights])
    #     insight_ids = [i for i in i_results if i]
    #     
    #     TestLogger.success(f"Created {len(insight_ids)} insights.")
    #
    #     # 5. Sequential Polling Loop for Insights
    #     TestLogger.section("‚è≥ Step 4: Polling Insights (Sequential Check Loop)")
    #     
    #     completed_insights = set()
    #     failed_insights = set()
    #     
    #     while len(completed_insights) + len(failed_insights) < len(insight_ids):
    #         for iid in insight_ids:
    #             if iid in completed_insights or iid in failed_insights:
    #                 continue
    #             
    #             try:
    #                 data = await self.api.get_insight(iid)
    #                 status = data["status"]
    #                 
    #                 if status == "completed":
    #                     print(f"   ‚úÖ Insight {iid} -> completed")
    #                     completed_insights.add(iid)
    #                 elif status == "error":
    #                     print(f"   ‚ùå Insight {iid} -> error: {data.get('error_message')}")
    #                     failed_insights.add(iid)
    #             except Exception as e:
    #                 print(f"   ‚ö†Ô∏è Error polling insight {iid}: {e}")
    #         
    #         print(f"   --- Insights: {len(completed_insights)} completed, {len(failed_insights)} failed ---")
    #         
    #         if len(completed_insights) + len(failed_insights) == len(insight_ids):
    #             break
    #             
    #         await asyncio.sleep(POLL_INTERVAL)
    #
    #     TestLogger.section("üéâ TEST COMPLETE")

    async def run_simple_test(self, folder_path: str):
        """Simple test: 3 docs, 3 insights, 3 chats"""
        TestLogger.section("üöÄ STARTING SIMPLE TEST (3 docs, 3 insights, 3 chats)")
        
        # 1. Gather 3 PDF files
        p = Path(folder_path)
        files = sorted(list(p.glob("*.pdf")))
        if not files:
            TestLogger.error(f"No PDF files found in {folder_path}")
            return
        
        target_files = files[:3]
        if len(target_files) < 3:
            TestLogger.error(f"Need at least 3 PDF files, found {len(target_files)}")
            return
        
        TestLogger.info(f"Selected {len(target_files)} files for testing")
        
        # 2. Upload 3 documents sequentially
        TestLogger.section("üì§ Step 1: Uploading 3 Documents")
        for fp in target_files:
            try:
                doc_id = await self.api.upload_document(self.user_id, fp)
                self.doc_ids.append(doc_id)
                self.doc_map[doc_id] = fp.name
                print(f"   ‚¨ÜÔ∏è  Uploaded {fp.name} -> {doc_id}")
            except Exception as e:
                TestLogger.error(f"Failed to upload {fp.name}: {e}")
                return
        
        TestLogger.success(f"Uploaded {len(self.doc_ids)}/3 documents.")
        
        # 3. Poll documents until all completed
        TestLogger.section("‚è≥ Step 2: Waiting for Documents to Process")
        completed_ids = set()
        failed_ids = set()
        
        while len(completed_ids) + len(failed_ids) < len(self.doc_ids):
            for doc_id in self.doc_ids:
                if doc_id in completed_ids or doc_id in failed_ids:
                    continue
                
                try:
                    doc = await self.api.get_document(doc_id)
                    status = doc["status"]
                    
                    if status == "completed":
                        print(f"   ‚úÖ {self.doc_map[doc_id]} -> completed")
                        completed_ids.add(doc_id)
                    elif status == "error":
                        print(f"   ‚ùå {self.doc_map[doc_id]} -> error: {doc.get('error_message', 'Unknown error')}")
                        failed_ids.add(doc_id)
                    else:
                        print(f"   ‚è≥ {self.doc_map[doc_id]} -> {status}")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Error polling {doc_id}: {e}")
            
            if len(completed_ids) + len(failed_ids) == len(self.doc_ids):
                break
                
            await asyncio.sleep(POLL_INTERVAL)
        
        if not completed_ids:
            TestLogger.error("No documents completed successfully. Cannot proceed.")
            return
        
        # 4. Create insights for all completed documents (up to 3)
        TestLogger.section("üß† Step 3: Creating Insights")
        insight_ids = []
        valid_docs = list(completed_ids)
        num_insights_to_create = min(3, len(valid_docs))
        
        if num_insights_to_create == 0:
            TestLogger.error("No completed documents available for insights. Skipping insights step.")
            return
        
        for i, doc_id in enumerate(valid_docs[:num_insights_to_create], 1):
            try:
                iid = await self.api.create_insight(
                    self.user_id, [doc_id], "summary", f"Test Summary {i}"
                )
                insight_ids.append(iid)
                print(f"   üöÄ Created insight {i} for {self.doc_map[doc_id]} -> {iid}")
            except Exception as e:
                TestLogger.error(f"Failed to create insight for {self.doc_map[doc_id]}: {e}")
        
        TestLogger.success(f"Created {len(insight_ids)}/{num_insights_to_create} insights.")
        
        # 5. Poll insights until all completed
        TestLogger.section("‚è≥ Step 4: Waiting for Insights to Complete")
        completed_insights = set()
        failed_insights = set()
        
        while len(completed_insights) + len(failed_insights) < len(insight_ids):
            for iid in insight_ids:
                if iid in completed_insights or iid in failed_insights:
                    continue
                
                try:
                    data = await self.api.get_insight(iid)
                    status = data["status"]
                    
                    if status == "completed":
                        print(f"   ‚úÖ Insight {iid} -> completed")
                        completed_insights.add(iid)
                    elif status == "error":
                        print(f"   ‚ùå Insight {iid} -> error: {data.get('error_message', 'Unknown error')}")
                        failed_insights.add(iid)
                    else:
                        print(f"   ‚è≥ Insight {iid} -> {status}")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Error polling insight {iid}: {e}")
            
            if len(completed_insights) + len(failed_insights) == len(insight_ids):
                break
                
            await asyncio.sleep(POLL_INTERVAL)
        
        # 6. Send chat messages (use only completed documents)
        TestLogger.section("üí¨ Step 5: Sending Chat Messages")
        valid_docs = list(completed_ids)
        
        if len(valid_docs) == 0:
            TestLogger.error("No completed documents available for chat. Skipping chat step.")
            return
        
        # Create chat messages based on available documents
        chat_messages = []
        if len(valid_docs) >= 1:
            chat_messages.append(("What is the main topic of this document?", valid_docs[:1]))
        if len(valid_docs) >= 2:
            chat_messages.append(("Can you summarize the key points from these documents?", valid_docs[:2]))
        if len(valid_docs) >= 3:
            chat_messages.append(("What are the common themes across all these documents?", valid_docs[:3]))
        else:
            # If we have less than 3 docs, add one more with all available docs
            chat_messages.append(("What are the key insights from these documents?", valid_docs))
        
        chat_responses = []
        for i, (message, doc_ids_for_chat) in enumerate(chat_messages, 1):
            try:
                response = await self.api.chat_message(self.user_id, message, doc_ids_for_chat)
                chat_responses.append(response)
                content = response.get('content', '')
                content_preview = content[:100] if content else 'N/A'
                print(f"   üí¨ Chat {i}: {message[:50]}...")
                print(f"      Response: {content_preview}...")
                print(f"      Documents used: {len(doc_ids_for_chat)}")
                print(f"      Message IDs: user={response.get('user_message_id')}, assistant={response.get('assistant_message_id')}")
            except Exception as e:
                TestLogger.error(f"Failed to send chat message {i}: {e}")
                import traceback
                print(f"      Error details: {traceback.format_exc()}")
        
        TestLogger.success(f"Sent {len(chat_responses)}/{len(chat_messages)} chat messages.")
        
        # 7. Verify chat history
        TestLogger.section("üìú Step 6: Verifying Chat History")
        try:
            history_response = await self.api.get_chat_history(self.user_id)
            # API returns {"messages": [...], "count": N}
            if isinstance(history_response, dict):
                messages = history_response.get("messages", [])
                count = history_response.get("count", len(messages))
            else:
                # Fallback if API structure is different
                messages = history_response if isinstance(history_response, list) else []
                count = len(messages)
            
            print(f"   üìú Found {count} messages in chat history")
            if messages:
                # Show last 10 messages (most recent)
                messages_to_show = messages[-10:] if len(messages) > 10 else messages
                for i, msg in enumerate(messages_to_show, 1):
                    role = msg.get('role', 'unknown')
                    content = msg.get('content', msg.get('message', ''))
                    content_preview = content[:60] if content else '(empty)'
                    msg_id = msg.get('id', 'N/A')
                    print(f"      {i}. [{role}] (id={msg_id}): {content_preview}...")
            else:
                print(f"      ‚ö†Ô∏è No messages found in history")
        except Exception as e:
            TestLogger.error(f"Failed to get chat history: {e}")
            import traceback
            print(f"      Error details: {traceback.format_exc()}")
        
        # 8. Summary
        TestLogger.section("üéâ TEST COMPLETE")
        print(f"\nüìä Summary:")
        print(f"   ‚úÖ Documents: {len(completed_ids)}/{len(self.doc_ids)} completed")
        if failed_ids:
            print(f"   ‚ùå Documents failed: {len(failed_ids)}")
            for doc_id in failed_ids:
                try:
                    doc = await self.api.get_document(doc_id)
                    error_msg = doc.get('error_message', 'Unknown error')
                    print(f"      - {self.doc_map.get(doc_id, doc_id)}: {error_msg[:80]}...")
                except:
                    print(f"      - {self.doc_map.get(doc_id, doc_id)}: (could not fetch error)")
        print(f"   ‚úÖ Insights: {len(completed_insights)}/{len(insight_ids)} completed")
        if failed_insights:
            print(f"   ‚ùå Insights failed: {len(failed_insights)}")
        print(f"   ‚úÖ Chat Messages: {len(chat_responses)}/{len(chat_messages) if 'chat_messages' in locals() else 'N/A'} sent")
        print(f"   üë§ User ID: {self.user_id}")

    async def close(self):
        await self.api.close()

async def main():
    parser = argparse.ArgumentParser(description="InsightForge Pipeline Test Runner")
    parser.add_argument("--stress", action="store_true", help="Run full stress test (commented out)")
    parser.add_argument("--dir", default="tests/Assignments", help="Directory containing PDFs")
    
    args = parser.parse_args()
    
    runner = StressTestRunner()
    
    try:
        if not await runner.api.health_check():
            TestLogger.error("API is not reachable at start. Aborting.")
            return

        if args.stress:
            TestLogger.error("Stress test is currently commented out. Use default simple test instead.")
            # await runner.run_stress_test(args.dir)  # Commented out
        else:
            # Run simple test by default
            await runner.run_simple_test(args.dir)
            
    finally:
        await runner.close()

if __name__ == "__main__":
    asyncio.run(main())
